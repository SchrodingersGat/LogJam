import re,os
import time

from math import ceil, log

from code_writer import CodeWriter

#LOGJAM version
LOGJAM_VERSION = "0.1"
    
#bitfield struct of the format Device_LogBitfield_t"
def bitfieldStruct(prefix):
    return "Log{prefix}_Bitfield_t".format(prefix=prefix)
    
#data struct for the format Device_LogData_t
def dataStruct(prefix):
    return "Log{prefix}_Data_t".format(prefix=prefix)

#header file define string
def headerDefine(prefix):
    return "_LOG_{prefix}_DEFS_H_".format(prefix=prefix.upper())
    
#header file name
def headerFilename(prefix):
    return "log_{prefix}_defs".format(prefix=prefix.lower())
    
def leftShift(n):
    if n == 0:
        return '& 0xFF'
    else:
        return '<< {n}'.format(n=int(n*8))
        
def rightShift(n):
    if n == 0:
        return '& 0xFF'
    else:
        return '>> {n}'.format(n=int(n*8))
    
    
class LogFile:
    def __init__(self, vars, prefix, version, outputdir=None):
        self.variables = vars
        self.prefix = prefix
        self.version = version
        
        hfile = headerFilename(prefix) + '.h'
        cfile = headerFilename(prefix) + '.c'
        
        if outputdir:
            hfile = os.path.join(outputdir, hfile)
            cfile = os.path.join(outputdir, cfile)
        
        self.hFile = CodeWriter(hfile)
        self.cFile = CodeWriter(cfile)
    
    def createHeaderEntry(self):
        self.hFile.startIf(headerDefine(self.prefix),invert=True)
        self.hFile.define(headerDefine(self.prefix))
        
    def createHeaderExit(self):
        self.hFile.endIf()
        
    def createHeaderInclude(self):
        self.cFile.include('"{file}.h"'.format(file=headerFilename(self.prefix)))
        
    def createAutogenInfo(self):
        self.hFile.startComment()
        self.hFile.appendLine("Logging structure definitions for the {device}".format(device=self.prefix))
        self.hFile.appendLine("This file was created using LogJam v{version}".format(version=LOGJAM_VERSION))
        self.hFile.appendLine("Generated at " + time.ctime())
        self.hFile.appendLine("LogJam - https://github.com/SchrodingersGat/LogJam")
        self.hFile.finishComment()
        self.hFile.appendLine()
        
    def createVersionString(self):
    
        major, minor = self.version.split('.')
        self.hFile.define("Log{prefix}_GetVersion()".format(prefix=self.prefix),
                          '"{version}"'.format(version=self.version),
                          comment="{prefix} Log revision number string".format(prefix=self.prefix))
        self.hFile.define("LOG_{prefix}_VERSION_MAJOR".format(prefix=self.prefix.upper()),
                          "{version}".format(version=major),
                          comment="Major version number")
        self.hFile.define("LOG_{prefix}_VERISION_MINOR".format(prefix=self.prefix.upper()),
                          "{version}".format(version=minor),
                          comment="Minor version number")
        self.hFile.appendLine()
        
    def createDoNotEat(self):
        self.hFile.startComment()
        self.hFile.appendLine('Do not edit this file!')
        self.hFile.appendLine('This file was auto-generated and any changes will be overwritten')
        self.hFile.appendLine('Edit the source .xml document instead')
        self.hFile.finishComment()
        self.hFile.appendLine()
        
    def constructCodeFile(self):
        
        self.cFile.clear()
        
        #include the header file
        self.createHeaderInclude()
        
        self.cFile.appendLine()
        
        #add in the global functions
        self.cFile.startComment()
        self.cFile.appendLine("Global functions")
        self.cFile.finishComment()
        
        self.createResetFunction()
        self.createCopyAllToFunction()
        self.createCopyDataToFunction()
        self.createCopyAllFromFunction()
        self.createCopyDataFromFunction()
        
        self.cFile.appendLine()
        self.cFile.startComment()
        self.cFile.appendLine("Individual variable functions")
        self.cFile.finishComment()
        
        self.cFile.appendLine()
        
        #add in the functions to add variables
        for v in self.variables:
            self.createAdditionFunction(v)
            self.createRemoveFunction(v)
            self.createDecodeFunction(v)
       
        self.titleByIndexFunction()
        self.unitsByIndexFunction()
        self.bitByIndexFunction()
        self.valueByIndexFunction()
       
    def constructHeaderFile(self):
        
        self.hFile.clear()
        
        self.createDoNotEat()
        
        self.createHeaderEntry()
        
        self.hFile.appendLine()
        
        self.hFile.include('<stdint.h>', comment='Primitive definitions')
        self.hFile.include('<string.h>', comment='memcpy function')
        self.hFile.include('<stdio.h>', comment='sprintf function')
        self.hFile.include('<stdbool.h>', comment='bool primitives')
        
        self.hFile.appendLine()
        
        self.hFile.externEntry()
        
        self.createAutogenInfo()
        self.createVersionString()
        
        self.hFile.appendLine()
        self.createGlobalEnum()
        
        self.hFile.appendComment("Bitfield struct definition for the " + self.prefix + " logging struct")
        self.createBitfieldStruct()
        self.hFile.appendLine()
        self.hFile.appendComment("Data struct definition for the " + self.prefix + " logging struct")
        self.createDataStruct()
        
        self.hFile.appendLine()
        
        self.hFile.startComment()
        self.hFile.appendLine("Global Functions:")
        self.hFile.finishComment()
        
        self.hFile.appendComment("Reset the bitfield of the logging structure")
        self.hFile.appendLine(self.resetPrototype() + ";")
        
        self.hFile.appendComment('Copy *all* data from the logging structure')
        self.hFile.appendLine(self.copyAllPrototype() + ';')
        
        self.hFile.appendComment("Copy *selected* data from the logging structure")
        self.hFile.appendLine(self.copySelectedPrototype() + ";")
        
        self.hFile.appendComment('Copy all data back out from a buffer')
        self.hFile.appendLine(self.copyAllFromPrototype() + ';')
        
        self.hFile.appendComment('Copy *selected* data back out from a buffer')
        self.hFile.appendLine(self.copyDataFromPrototype() + ';')
        
        self.hFile.appendLine()
        
        self.hFile.appendComment("Functions for getting variable information based on the index");
        self.hFile.appendLine(self.titleByIndexPrototype()+';')
        self.hFile.appendLine(self.unitsByIndexPrototype()+';')
        self.hFile.appendLine(self.bitByIndexPrototype() + ';')
        self.hFile.appendLine(self.valueByIndexPrototype() + ';')
        
        self.hFile.appendLine()
        
        self.hFile.startComment()
        self.hFile.appendLine("Variable Functions:")
        self.hFile.appendLine("These functions are applied to individual variables within the logging structure")
        self.hFile.finishComment()
        
        #add in the 'addition' functions
        for var in self.variables:
            self.hFile.appendLine(self.additionPrototype(var) + '; //Add ' + var.prefix + " to the log struct")
            self.hFile.appendLine(self.removePrototype(var) + '; //Remove ' + var.prefix + ' from the log struct')
            self.hFile.appendLine(self.decodePrototype(var) + '; //Decode ' + var.prefix + ' into a printable string')
            
        self.hFile.appendLine()
        self.hFile.appendComment('Title and Unit string functions for all variables')
        #defines for extracting title and unit information
        for var in self.variables:
            self.hFile.define('Log{prefix}_{name}Title() {title}'.format(
                prefix=self.prefix,
                name=var.name,
                title=var.getTitleString()),
                comment='Title string for {var} variable'.format(var=var.name))
                
            self.hFile.define('Log{prefix}_{name}Units() {units}'.format(
                prefix=self.prefix,
                name=var.name,
                units=var.getUnitsString()),
                comment='Units string for {var} variable'.format(var=var.name))
                
            self.hFile.appendLine()
        
        self.hFile.appendLine()
        self.hFile.externExit()
        
        self.createHeaderExit()
    
    def saveFiles(self):
        
        self.constructHeaderFile()
        self.constructCodeFile()
        
        self.hFile.writeToFile()
        self.cFile.writeToFile() 
        
    #create the enumeration of all the variables
    def createGlobalEnum(self):
        self.hFile.appendComment('Global enum of all variables available for the {prefix} logging structure'.format(prefix=self.prefix))
        self.hFile.appendLine('typedef enum')
        self.hFile.openBrace()
        
        for v in self.variables:
            self.hFile.appendLine(v.getEnum() + ', {comment}'.format(comment=v.comment))
        
        #give it a name
        self.hFile.tabOut()
        self.hFile.appendLine('}} Log{pref}_Enum_t;\n'.format(pref=self.prefix))
        
        self.hFile.appendComment('Number of parameters in the {pref} logging structure'.format(pref=self.prefix))
        
        self.hFile.define('LOG_{pref}_VARIABLE_COUNT'.format(pref=self.prefix.upper()),
                          value=str(len(self.variables)))
                          
        self.hFile.appendLine()
        
        
    #create the struct of the variables
    def createDataStruct(self):
    
        self.hFile.appendLine('typedef struct {')
        
        self.hFile.tabIn()
        
        for v in self.variables:
            self.hFile.appendComment('Variable : {name}, {units}'.format(name=v.name,units=v.units if v.units else 'no units specified'))
            
            if v.scaler > 1:
                self.hFile.appendComment('{name} will be scaled by 1.0/{scaler} when decoded to a log file'.format(name=v.name,scaler=v.scaler))
            self.hFile.appendLine(v.dataString())
        
        self.hFile.tabOut()
        
        self.hFile.appendLine('} ' + dataStruct(self.prefix) + ';')
        
    #create a bitfield struct of all variables
    def createBitfieldStruct(self):
    
        self.hFile.appendLine('typedef struct {')
        
        self.hFile.tabIn()
        
        for v in self.variables:
            self.hFile.appendLine(v.bitfieldString())
            
        self.hFile.tabOut()
        
        self.hFile.appendLine('} ' + bitfieldStruct(self.prefix) + ';')
        
    def removePrototype(self,var):
        return self.createVariableFunction(var,'remove',blank=True,inline=True,data=False)
        
    #create a function to remove a var from the logging structure
    def createRemoveFunction(self, var):
        self.cFile.appendComment("Remove variable {name} from the {prefix} logging structure".format(name=var.name,prefix=self.prefix))
        self.cFile.appendLine(self.removePrototype(var))
        self.cFile.openBrace()
        self.cFile.appendLine(var.clearBit('selection'))
        self.cFile.closeBrace()
        self.cFile.appendLine()
        
    def additionPrototype(self,var):
        return self.createVariableFunction(var,'add',inline=True)
        
    #create the function for adding a variable to the logging structure
    def createAdditionFunction(self, var):
    
        self.cFile.appendComment('Add variable {name} to the {prefix} logging struct'.format(
                        name=var.name,
                        prefix=self.prefix))
                        
        self.cFile.appendLine(self.additionPrototype(var))
        self.cFile.openBrace()
        self.cFile.appendLine(var.setBit('selection'))
        #now actually add the variable in
        self.cFile.appendLine(var.addVariable('data'))
        self.cFile.closeBrace()
        self.cFile.appendLine()
        
    #function for decoding a particular variable into a printable string for writing to a log file
    def decodePrototype(self, var):
        return self.createVariableFunction(var,'decode',blank=True,bits=False,returnType='void',extra=[('*str','char')])
    
    def createDecodeFunction(self, var):
        self.cFile.appendComment('Decode the {name} variable and return a printable string (e.g. for saving to a log file'.format(name=var.name))
        self.cFile.appendComment('Pointer to *str must have enough space allocated!')
        self.cFile.appendLine(self.decodePrototype(var))
        self.cFile.openBrace()
        line = ''
        #perform scaling!
        scale = var.scaler > 1
        
        if not scale:
            pattern = '"%{sign}",{var}'.format(sign='u' if var.format.startswith('u') else 'd',var=var.getPtr('data'))
        else:
            pattern = '"%.{n}f",(float) {var} / {scaling}'.format(
                n = ceil(log(var.scaler) / log(10)),
                var=var.getPtr('data'),
                scaling=var.scaler)
            
        self.cFile.appendLine('sprintf(str,{patt});'.format(patt=pattern))
        self.cFile.closeBrace()
        self.cFile.appendLine()
        pass
        
    #create a function pointing to a particular variable
    def createVariableFunction(self, var, name, blank=False, extra=None,ptr=False, **params):
        name = var.getFunctionName(name)
        
        if not extra:
            extra = []
        
        if not blank:
            extra.append(('{ptr}{name}'.format(ptr='*' if ptr else '',name=var.name),var.format))
        
        return self.createFunctionPrototype(name,extra=extra,**params)
        
    """
    Create a function type of given NAME
    name - name of the function
    data - Include a pointer to the LogData_t struct?
    bits - Include a pointer to the LogBitfield_t struct?
    inline - Make the function inline?
    returnType - Function return type
    extra - Extra parameters to pass to the function - list of tuples
    """
    def createFunctionPrototype(self, name, data=True, bits=True, inline=False, returnType='void', extra=None):
        
        if not extra:
            extra = []
        
        #pass extra parameters to the function as such
        #params = {'*dest': 'void'} (name, type)
        paramstring = ""
        for pair in extra:
            paramstring += ', '
            paramstring += pair[1]
            paramstring += ' '
            paramstring += pair[0]
            
        return '{inline}{returnType} Log{prefix}_{name}({data}{comma}{bits}{params})'.format(
                    inline='inline ' if inline else '',
                    returnType=returnType,
                    prefix=self.prefix.capitalize(),
                    name=name,
                    comma=', ' if data and bits else '',
                    data=dataStruct(self.prefix) + " *data" if data else "",
                    bits=bitfieldStruct(self.prefix) + " *selection" if bits else "",
                    params=paramstring)
                    
    def resetPrototype(self):
        return self.createFunctionPrototype('Reset',data=False)
                    
    #create a function to reset the logging structure
    def createResetFunction(self):
        
        #add the reset function to the c file
        self.cFile.appendComment('Reset the log data struct (e.g. after writing to memory)')
        self.cFile.appendComment('Only the selection bits need to be reset')
        self.cFile.appendLine(self.resetPrototype())
        self.cFile.openBrace()
        
        self.cFile.appendLine("memset(selection,0,sizeof(" + bitfieldStruct(self.prefix) + "));")
        
        self.cFile.closeBrace()
        self.cFile.appendLine()
        
    """
    Functions for copying data out of a struct and into a linear buffer
    """
    def copyAllPrototype(self):
        return self.createFunctionPrototype('CopyAllToBuffer',bits=False,extra=[('*dest','void')])
        
    #create a function to copy ALL parameters across, conserving data format
    def createCopyAllToFunction(self):
        
        self.cFile.appendComment("Copy ALL data in the log struct to the provided address")
        self.cFile.appendComment("Data will be copied even if the associated selection bit is cleared")
        
        self.cFile.appendLine(self.copyAllPrototype())
        self.cFile.openBrace()
        
        for var in self.variables:
            self.copyVarToBuffer(var)
        
        self.cFile.closeBrace()
        self.cFile.appendLine()

    def copySelectedPrototype(self):
        return self.createFunctionPrototype('CopyDataToBuffer',extra=[('*dest','void')], returnType='uint16_t')
        
    #create a function that copies across ONLY the bits that are set
    def createCopyDataToFunction(self):
        self.cFile.appendComment("Copy across data whose selection bit is set in the provided bitfield")
        self.cFile.appendComment("Only data selected will be copied (in sequence)")
        self.cFile.appendComment("Ensure a copy of the selection bits is stored for decoding")
        self.cFile.appendLine(self.copySelectedPrototype());
        self.cFile.openBrace()
        self.cFile.appendLine('void *ptr = dest; //Pointer for keeping track of data addressing')
        self.cFile.appendLine('uint16_t count = 0; //Variable for keeping track of how many bytes were copied')
        self.cFile.appendLine()
        self.cFile.appendComment('Copy the selection for keeping track of data')
        self.cFile.appendLine('memcpy(ptr, selection, sizeof({struct}));'.format(struct=bitfieldStruct(self.prefix)))
        self.cFile.appendLine('ptr += sizeof({struct});'.format(struct=bitfieldStruct(self.prefix)))
        self.cFile.appendLine()
        self.cFile.appendComment('Check each variable in the logging struct to see if it should be added')
        
        for var in self.variables:
            self.cFile.appendLine(var.checkBit('selection'))
            self.cFile.openBrace()
            
            self.copyVarToBuffer(var, count=True)
            self.cFile.closeBrace()
        
        self.cFile.appendLine()
        self.cFile.appendLine('return count; //Return the number of bytes that were actually copied')
        self.cFile.closeBrace()
        self.cFile.appendLine()
        
    def copyVarToBuffer(self, var, count=False):
        for i in range(var.bytes):
            self.cFile.appendLine('ptr[i++] = (uint8_t) ({data} {shift});'.format(
                data = var.getPtr('data'),
                shift = rightShift(i)))
        if count:
            self.cFile.appendLine('count += {size};'.format(size=var.bytes))
            
    def copyVarFromBuffer(self, var, count=False):
        for i in range(var.bytes):
            self.cFile.appendLine('{data} {pipe}= ({format}) ptr[i++] {shift};'.format(
                data = var.getPtr('data'),
                pipe = '|' if i > 0 else ' ',
                format = var.format,
                shift = leftShift(i)))
                
        if count:
            self.cFile.appendLine('count += {size};'.format(size=var.bytes))
        
    """
    Functions for copying data back out of a buffer
    """
    def copyAllFromPrototype(self):
        return self.createFunctionPrototype(
                            'CopyAllFromBuffer',
                            bits = False,
                            extra = [('*src','void')])
                            
    def createCopyAllFromFunction(self):
        self.cFile.appendComment("Copy across *all* data from a buffer")
        self.cFile.appendComment("Data will be copied even if it is invalid (selection bit is cleared)")
        self.cFile.appendLine(self.copyAllFromPrototype())
        self.cFile.openBrace()
        
        for var in self.variables:
            self.copyVarFromBuffer(var)
        
        self.cFile.closeBrace()
        self.cFile.appendLine()
        
    def copyDataFromPrototype(self):
        return self.createFunctionPrototype('CopyDataFromBuffer',
                                            returnType='uint16_t',
                                            extra = [('*src','void')])
                                            
    def createCopyDataFromFunction(self):
        self.cFile.appendComment("Copy across *selected* data from a buffer")
        self.cFile.appendLine(self.copyDataFromPrototype())
        self.cFile.openBrace()
        
        self.cFile.appendLine('void *ptr = src; //Pointer for keeping track of data addressing')
        self.cFile.appendLine('uint16_t count = 0; //Variable for keeping track of how many bytes were copied')
        self.cFile.appendLine()
        self.cFile.appendComment('Copy the selection bits')
        self.cFile.appendLine('memcpy(selection, ptr, sizeof({struct}));'.format(struct=bitfieldStruct(self.prefix)))
        self.cFile.appendLine('ptr += sizeof({struct});'.format(struct=bitfieldStruct(self.prefix)))
        self.cFile.appendLine()
        self.cFile.appendComment('Only copy across variables that have actually been stored in the buffer')
        
        for var in self.variables:
            self.cFile.appendLine(var.checkBit('selection'))
            self.cFile.openBrace()
            
            self.copyVarFromBuffer(var,count=True)
            
            self.cFile.closeBrace()
            
        self.cFile.appendLine()
        self.cFile.appendLine('return count; //Return the number of bytes that were actually copied')
        
        self.cFile.closeBrace()
        self.cFile.appendLine()
        
        
    #enumerate through all the varibles in the struct, perform 'function' for each
    def createCaseEnumeration(self, blankFunction=None, returnFunction=None):
        
        for var in self.variables:
            self.cFile.addCase(var.getEnum())
            
            if blankFunction:
                blank = blankFunction(var)
                if not blank.endswith(';'):
                    blank += ';'
                self.cFile.appendLine(blank)
            if returnFunction:
                self.cFile.returnFromCase(returnFunction(var))
            else:
                self.cFile.breakFromCase()

    def titleByIndexPrototype(self):
        return 'char* Log{pref}_GetTitleByIndex(uint8_t index)'.format(pref=self.prefix)
        
    def titleByIndexFunction(self):
        self.cFile.appendComment('Get the title of a variable based on its enumerated value')
        self.cFile.appendLine(self.titleByIndexPrototype())
        self.cFile.openBrace()
        
        self.cFile.startSwitch('index')
        
        #add case labels
        #function to return the index
        fn = lambda var: 'Log{prefix}_{var}Title()'.format(prefix=self.prefix,var=var.name)
        
        self.createCaseEnumeration(returnFunction = fn)
        
        self.cFile.endSwitch()
        
        self.cFile.appendComment('Default return value')
        self.cFile.appendLine('return "";')
        
        self.cFile.closeBrace()
        self.cFile.appendLine()
        
    def unitsByIndexPrototype(self):
        return 'char* Log{pref}_GetUnitsByIndex(uint8_t index)'.format(pref=self.prefix)
        
    def unitsByIndexFunction(self):
        self.cFile.appendComment('Get the units of a variable based on its enumerated value')
        self.cFile.appendLine(self.unitsByIndexPrototype())
        self.cFile.openBrace()
        
        self.cFile.startSwitch('index')
        
        fn = lambda var: 'Log{prefix}_{var}Units()'.format(prefix=self.prefix,var=var.name)
        
        self.createCaseEnumeration(returnFunction = fn)
        
        self.cFile.endSwitch()
        
        self.cFile.appendComment('Default return value')
        self.cFile.appendLine('return "";')
        
        self.cFile.closeBrace()
        self.cFile.appendLine()
        
    def bitByIndexPrototype(self):
        return self.createFunctionPrototype('GetBitByIndex',data=False,returnType='bool',extra=[('index','uint8_t')])
        
    def bitByIndexFunction(self):
        self.cFile.appendComment('Check a selection bit based on its enumerated value')
        self.cFile.appendLine(self.bitByIndexPrototype())
        self.cFile.openBrace()
        
        self.cFile.startSwitch('index')
        
        fn = lambda var: 'selection->{name} == 1'.format(name=var.name)
        
        self.createCaseEnumeration(returnFunction = fn)
        
        self.cFile.endSwitch()
        
        self.cFile.appendComment("Default return value")
        self.cFile.appendLine("return false;");
        
        self.cFile.closeBrace()
        self.cFile.appendLine()
        
    def valueByIndexPrototype(self):
        return self.createFunctionPrototype('GetValueByIndex',bits=False,extra=[('index','uint8_t'), ('*str','char')])
        
    def valueByIndexFunction(self):
        self.cFile.appendComment('Get a string-representation of a given variable, based on its enumerated value')
        self.cFile.appendLine(self.valueByIndexPrototype())
        self.cFile.openBrace()
        
        self.cFile.startSwitch('index')
        
        fn = lambda var: 'Log{prefix}_Decode{name}(data,str)'.format(prefix=self.prefix.capitalize(),name=var.name.capitalize())
        
        self.createCaseEnumeration(blankFunction=fn)
        
        self.cFile.endSwitch()
        
        self.cFile.closeBrace()
        self.cFile.appendLine()
        
class LogVariable:

    #prefix = name of the 'device'
    #name = name of this variable
    #format = primitive datatype
    #comment = comment string
    def __init__(self, prefix, name, format, comment=None, units=None, scaler=1.0):
        self.prefix = prefix
        self.name = name
        self.format = self.parseFormat(format)
        self.comment = "//!< " + str(comment) if comment else ""
        self.units = units
        self.scaler = scaler
        
        #get the number of bytes in this variable
        result = re.match('u*int(\d*)',self.format)
        
        self.bytes = int(int(result.groups()[0]) / 8)
        
    def parseFormat(self, format):
        format = format.replace("unsigned","uint")
        format = format.replace("signed","int")
        if not format.endswith("_t"):
            format = format + "_t"
            
        return format
        
    #datatype definition string (with comment appended)
    def dataString(self):
        return "{datatype} {name}; {comment}".format(
                datatype = self.format,
                name = self.name,
                comment = self.comment)
                
    #bitfield definition string (with comment appended)
    def bitfieldString(self):
        return "uint8_t {name} : 1; {comment}".format(
                name = self.name,
                comment = self.comment)
                
    #wrap a given function name
    def getFunctionName(self, fnName):
        return "{fn}{name}".format(name=self.name.capitalize(), fn=fnName.capitalize())
        
    #return an enum line
    def getEnum(self):
        return "LOG_{pref}_{name}".format(pref=self.prefix.upper(),name=self.name.upper())
        
    #assume there is always a pointer to *log
    
    #get the pointer to the data type within a given struct
    def getPtr(self, struct):
        return '{struct}->{name}'.format(struct=struct,name=self.name)
    
    #check if a bit is set
    #returns a string of the format 'if (bits->name)'
    def checkBit(self,struct='bits'):
        return 'if ({bit})'.format(bit=self.getPtr(struct))
        
    #check if a bit is not set
    def checkNotBit(self,struct='bits'):
        return 'if ({bit} == 0)'.format(bit=self.getPtr(struct))
        
    #code prototype to set the selection bit
    def setBit(self,struct='bits'):
        return '{bit} = 1; //Set the {name} bit'.format(bit=self.getPtr(struct), name=self.name)
        
    #code prototype to clear the selection bit
    def clearBit(self,struct='bits'):
        return '{bit} = 0; //Clear the {name} bit'.format(bit=self.getPtr(struct), name=self.name)
        
    def getSize(self, struct):
        return 'sizeof({struct}->{name})'.format(struct=struct,name=self.name)
        
    #add the variable to the struct
    def addVariable(self, struct):
        return "{struct}->{name} = {name}; //Add the '{name}' variable".format(struct=struct,name=self.name)
        
    def getTitleString(self):
        return '"{name}"'.format(name=self.name)
        
    def getUnitsString(self):
        if not self.units:
            return '""'
        else:
            return '"{units}"'.format(units=self.units)
