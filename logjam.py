import re,os
import time

from code_writer import CodeWriter

#LOGJAM version
LOGJAM_VERSION = "0.1"

#log entry struct of the format Device_LogEntry_t
def topLevelStruct(prefix):
    return "{prefix}_LogEntry_t".format(prefix=prefix)
    
#bitfield struct of the format Device_LogBitfield_t"
def bitfieldStruct(prefix):
    return "{prefix}_LogBitfield_t".format(prefix=prefix)
    
#data struct for the format Device_LogData_t
def dataStruct(prefix):
    return "{prefix}_LogData_t".format(prefix=prefix)

#header file define string
def headerDefine(prefix):
    return "_LOG_{prefix}_DEFS_H_".format(prefix=prefix.upper())
    
#header file name
def headerFilename(prefix):
    return "log_{prefix}_defs".format(prefix=prefix.lower())
    
class LogFile:
    def __init__(self, vars, prefix, version, outputdir=None):
        self.variables = vars
        self.prefix = prefix
        self.version = version
        
        hfile = headerFilename(prefix) + '.h'
        cfile = headerFilename(prefix) + '.c'
        
        if outputdir:
            hfile = os.path.join(outputdir, hfile)
            cfile = os.path.join(outputdir, cfile)
        
        self.hFile = CodeWriter(hfile)
        self.cFile = CodeWriter(cfile)
    
    def createHeaderEntry(self):
        self.hFile.startIf(headerDefine(self.prefix),invert=True)
        self.hFile.define(headerDefine(self.prefix))
        
    def createHeaderExit(self):
        self.hFile.endIf()
        
    def createHeaderInclude(self):
        self.cFile.include('"{file}.h"'.format(file=headerFilename(self.prefix)))
        
    def createAutogenInfo(self):
        self.hFile.startComment()
        self.hFile.appendLine("Logging structure definitions for the {device}".format(device=self.prefix))
        self.hFile.appendLine("This file was created using LogJam v{version}".format(version=LOGJAM_VERSION))
        self.hFile.appendLine("Generated at " + time.ctime())
        self.hFile.appendLine("LogJam - https://github.com/SchrodingersGat/LogJam")
        self.hFile.finishComment()
        self.hFile.appendLine()
        
    def createVersionString(self):
    
        major, minor = self.version.split('.')
        self.hFile.define("{prefix}_GetLogVersion()".format(prefix=self.prefix),
                          '"{version}";'.format(version=self.version),
                          comment="{prefix} Log revision number string".format(prefix=self.prefix))
        self.hFile.define("{prefix}_LOG_VERSION_MAJOR".format(prefix=self.prefix.upper()),
                          "{version}".format(version=major),
                          comment="Major version number")
        self.hFile.define("{prefix}_LOG_VERISION_MINOR".format(prefix=self.prefix.upper()),
                          "{version}".format(version=minor),
                          comment="Minor version number")
        self.hFile.appendLine()
        
    def createDoNotEat(self):
        self.hFile.startComment()
        self.hFile.appendLine('Do not edit this file!')
        self.hFile.appendLine('This file was auto-generated and any changes will be overwritten')
        self.hFile.appendLine('Edit the source .xml document instead')
        self.hFile.finishComment()
        self.hFile.appendLine()
        
    def constructCodeFile(self):
        
        self.cFile.clear()
        
        #include the header file
        self.createHeaderInclude()
        
        self.cFile.appendLine()
        
        #add in the global functions
        self.cFile.startComment()
        self.cFile.appendLine("Global functions")
        self.cFile.finishComment()
        
        self.createInitFunction()
        self.createResetFunction()
        self.createCopyAllFunction()
        self.createCopySelectedFunction()
        self.createCopyDataFunction()
        self.createCopyAllFromFunction()
        
        self.cFile.appendLine()
        self.cFile.startComment()
        self.cFile.appendLine("Individual variable functions")
        self.cFile.finishComment()
        
        self.cFile.appendLine()
        
        #add in the functions to add variables
        for v in self.variables:
            self.createAdditionFunction(v)
            self.createRemoveFunction(v)
       
    def constructHeaderFile(self):
        
        self.hFile.clear()
        
        self.createDoNotEat()
        
        self.createHeaderEntry()
        
        self.hFile.appendLine()
        
        self.hFile.include('<stdint.h>', comment='Primitive definitions')
        self.hFile.include('<string.h>', comment='memcpy function')
        
        self.hFile.appendLine()
        
        self.hFile.externEntry()
        
        self.createAutogenInfo()
        self.createVersionString()
        
        self.hFile.appendLine()
        self.createGlobalEnum()
        
        self.hFile.appendComment("Bitfield struct definition for the " + self.prefix + " logging struct")
        self.createBitfieldStruct()
        self.hFile.appendLine()
        self.hFile.appendComment("Data struct definition for the " + self.prefix + " logging struct")
        self.createDataStruct()
        self.hFile.appendLine()
        self.hFile.appendComment("Structure for complete definition of the " + self.prefix + " logging protocol")
        self.hFile.appendLine('typedef struct')
        self.hFile.openBrace()
        self.hFile.appendLine()
        self.hFile.appendComment("Bitfield defining which variables are selected")
        self.hFile.appendLine(bitfieldStruct(self.prefix) + " selection;")
        self.hFile.appendLine()
        self.hFile.appendComment("Struct defining the actual data to be logged")
        self.hFile.appendLine(dataStruct(self.prefix) + " data;")
        self.hFile.tabOut()
        self.hFile.appendLine()
        
        self.hFile.appendLine("} " + topLevelStruct(self.prefix) + ";")
        
        self.hFile.appendLine()
        
        self.hFile.startComment()
        self.hFile.appendLine("Global Functions:")
        self.hFile.appendLine("These functions are applied to the global struct " + topLevelStruct(self.prefix))
        self.hFile.finishComment()
        
        self.hFile.appendComment("Initialize the logging structure")
        self.hFile.appendLine(self.initPrototype() + ";")
        
        self.hFile.appendComment("Reset the bitfield of the logging structure")
        self.hFile.appendLine(self.resetPrototype() + ";")
        
        self.hFile.appendComment('Copy *all* data from the logging structure')
        self.hFile.appendLine(self.copyAllPrototype() + ';')
        
        self.hFile.appendComment("Copy *selected* data from the logging structure")
        self.hFile.appendLine(self.copySelectedPrototype() + ";")
        
        self.hFile.appendComment("Copy data that has been written")
        self.hFile.appendLine(self.copyDataPrototype() + ';')
        
        self.hFile.appendComment('Copy all data back out from a buffer')
        self.hFile.appendLine(self.copyAllFromPrototype() + ';')
        
        self.hFile.appendLine()
        
        self.hFile.startComment()
        self.hFile.appendLine("Variable Functions:")
        self.hFile.appendLine("These functions are applied to individual variables within the logging structure")
        self.hFile.finishComment()
        
        
        #add in the 'addition' functions
        for var in self.variables:
            self.hFile.appendLine(var.getFunctionPrototype('add',inline=True) + "; //Add " + var.prefix + " to the log struct")
            self.hFile.appendLine(self.removePrototype(var) + ';')
        
        
        self.hFile.appendLine()
        self.hFile.externExit()
        
        self.createHeaderExit()
    
    def saveFiles(self):
        
        self.constructHeaderFile()
        self.constructCodeFile()
        
        self.hFile.writeToFile()
        self.cFile.writeToFile() 
        
    #create the enumeration of all the variables
    def createGlobalEnum(self):
        self.hFile.appendComment('Global enum of all variables available for the {prefix} logging structure'.format(prefix=self.prefix))
        self.hFile.appendLine('typedef enum')
        self.hFile.openBrace()
        
        #start at zero
        self.hFile.appendLine('LOG_{pref}_NONE = 0x00,'.format(pref=self.prefix.upper()))
        
        for v in self.variables:
            self.hFile.appendLine(v.getEnum() + ',')
        
        #give it a name
        self.hFile.tabOut()
        self.hFile.appendLine('}} {pref}_LogEnum_t;\n'.format(pref=self.prefix))
        
        self.hFile.appendComment('Number of parameters in the {pref} logging structure'.format(pref=self.prefix))
        
        self.hFile.define('LOG_{pref}_VARIABLE_COUNT'.format(pref=self.prefix.upper()),
                          value=str(len(self.variables)))
                          
        self.hFile.appendLine()
        
        
    #create the struct of the variables
    def createDataStruct(self):
    
        self.hFile.appendLine('typedef struct {')
        
        self.hFile.tabIn()
        
        for v in self.variables:
            self.hFile.appendComment('Variable : {name}, {units}'.format(name=v.name,units=v.units))
            
            if v.scaler > 1:
                self.hFile.appendComment('{name} will be scaled by {scaler} when decoded to a log file'.format(name=v.name,scaler=v.scaler))
            self.hFile.appendLine(v.dataString())
        
        self.hFile.tabOut()
        
        self.hFile.appendLine('} ' + dataStruct(self.prefix) + ';')
        
    #create a bitfield struct of all variables
    def createBitfieldStruct(self):
    
        self.hFile.appendLine('typedef struct {')
        
        self.hFile.tabIn()
        
        for v in self.variables:
            self.hFile.appendLine(v.bitfieldString())
            
        self.hFile.tabOut()
        
        self.hFile.appendLine('} ' + bitfieldStruct(self.prefix) + ';')
        
    def removePrototype(self, var):
        return 'inline void {prefix}Log_Remove{name}({struct} *log)'.format(
                prefix=self.prefix,
                name=var.name.capitalize(),
                struct=topLevelStruct(self.prefix))
        
    #create a function to remove a var from the logging structure
    def createRemoveFunction(self, var):
        self.cFile.appendComment("Remove variable {name} from the {prefix} loggin structure".format(name=var.name,prefix=self.prefix))
        self.cFile.appendLine(self.removePrototype(var))
        self.cFile.openBrace()
        self.cFile.appendLine(var.clearBit())
        self.cFile.closeBrace()
        self.cFile.appendLine()
        
    #create the function for adding a variable to the logging structure
    def createAdditionFunction(self, var):
    
        self.cFile.appendComment('Add variable {name} to the {prefix} logging struct'.format(
                        name=var.name,
                        prefix=self.prefix))
                        
        self.cFile.appendLine(var.getFunctionPrototype('add',inline=True))
        self.cFile.openBrace()
        self.cFile.appendLine(var.setBit())
        #now actually add the variable in
        self.cFile.appendLine(var.addVariable())
        self.cFile.closeBrace()
        self.cFile.appendLine()
        
    def createFunctionPrototype(self, name, inline=False, returnType='void', params={}):
        
        #pass extra parameters to the function as such
        #params = {'*dest': 'void'} (name, type)
        paramstring = ""
        for k in params.keys():
            paramstring += ', '
            paramstring += params[k]
            paramstring += ' '
            paramstring += k
            
        return '{inline}{returnType} {prefix}Log_{name}({struct} *log{params})'.format(
                    inline='inline ' if inline else '',
                    returnType=returnType,
                    prefix=self.prefix.capitalize(),
                    name=name,
                    struct=topLevelStruct(self.prefix),
                    params=paramstring)
                    
    def resetPrototype(self):
        return self.createFunctionPrototype('Reset')
                    
    #create a function to reset the logging structure
    def createResetFunction(self):
        
        #add the reset function to the c file
        self.cFile.appendComment('Reset the log data struct (e.g. after writing to memory)')
        self.cFile.appendComment('Only the selection bits need to be reset')
        self.cFile.appendLine(self.resetPrototype())
        self.cFile.openBrace()
        
        self.cFile.appendLine("memset(&(log->selection),0,sizeof(" + bitfieldStruct(self.prefix) + "));")
        
        self.cFile.closeBrace()
        self.cFile.appendLine()
        
    def initPrototype(self):
        return self.createFunctionPrototype('Initialize')
        
    #create a func to initialize the logging structure
    def createInitFunction(self):
    
        self.cFile.appendComment("Initialize the log data struct to zero")
        self.cFile.appendLine(self.initPrototype())
        self.cFile.openBrace()
        self.cFile.appendLine('memset(log,0,sizeof({struct}));'.format(struct=topLevelStruct(self.prefix)))
        self.cFile.closeBrace()
        self.cFile.appendLine()
        
    """
    Functions for copying data out of a struct and into a linear buffer
    """
    def copyAllPrototype(self):
        return self.createFunctionPrototype('CopyAllToBuffer',params={'*dest' : 'void'})
        
    #create a function to copy ALL parameters across, conserving data format
    def createCopyAllFunction(self):
        
        self.cFile.appendComment("Copy ALL data in the log struct to the provided address")
        self.cFile.appendComment("Data will be copied even if the associated selection bit is cleared")
        
        self.cFile.appendLine(self.copyAllPrototype())
        self.cFile.openBrace()
        self.cFile.appendLine('memcpy(dest, &(log->data), sizeof({struct}));'.format(struct=dataStruct(self.prefix)))
        self.cFile.closeBrace()
        self.cFile.appendLine()

    def copySelectedPrototype(self):
        return self.createFunctionPrototype('CopySelectedToBuffer',params={'*selection' : bitfieldStruct(self.prefix), '*dest' : 'void'}, returnType='uint16_t')
        
    #create a function that copies across ONLY the bits that are set
    def createCopySelectedFunction(self):
        self.cFile.appendComment("Copy across data whose selection bit is set in the provided bitfield")
        self.cFile.appendComment("Only data selected will be copied (in sequence)")
        self.cFile.appendComment("Ensure a copy of the selection bits is stored for decoding")
        self.cFile.appendLine(self.copySelectedPrototype());
        self.cFile.openBrace()
        self.cFile.appendLine('void* ptr = dest; //Pointer for keeping track of data addressing')
        self.cFile.appendLine('uint16_t count = 0; //Variable for keeping track of how many bytes were copied')
        self.cFile.appendLine()
        self.cFile.appendComment('Copy the selection for keeping track of data')
        self.cFile.appendLine('memcpy(ptr, selection, sizeof({struct}));'.format(struct=bitfieldStruct(self.prefix)))
        self.cFile.appendLine('ptr += sizeof({struct});'.format(struct=bitfieldStruct(self.prefix)))
        self.cFile.appendLine()
        self.cFile.appendComment('Check each variable in the logging struct to see if it should be added')
        
        for var in self.variables:
            self.cFile.appendLine(var.checkExternalBit('selection'))
            self.cFile.openBrace()
            #copy the data across
            self.cFile.appendLine('memcpy(ptr, {ptr}, {size}); //Copy the data'.format(ptr=var.getPtr(), size=var.getSize()))
            self.cFile.appendLine('ptr += {size}; //Increment the pointer'.format(size=var.getSize()))
            self.cFile.appendLine('count += {size}; //Increase the count'.format(size=var.getSize()))
            self.cFile.closeBrace()
        
        self.cFile.appendLine()
        self.cFile.appendLine('return count; //Return the number of bytes that were actually copied')
        self.cFile.closeBrace()
        self.cFile.appendLine()        
        
    def copyDataPrototype(self):
        return self.createFunctionPrototype('CopyDataToBuffer',params={'*dest' : 'void'}, returnType='uint16_t')
        
    #create a function that copies across ONLY the bits that are set
    def createCopyDataFunction(self):
        self.cFile.appendComment("Copy across data whose selection bit is set within " + topLevelStruct(self.prefix))
        self.cFile.appendComment("Only data selected will be copied (in sequence)")
        self.cFile.appendComment("Ensure a copy of the selection bits is stored for decoding")
        self.cFile.appendLine(self.copyDataPrototype());
        self.cFile.openBrace()
        
        #we have already defined the CopySelected function, which can be chained here
        self.cFile.appendLine('return {prefix}Log_CopySelected(log,dest,&(log->selection));'.format(prefix=self.prefix.capitalize()))
        
        self.cFile.closeBrace()
        self.cFile.appendLine()
        
    """
    Functions for copying data back out of a buffer
    """
    def copyAllFromPrototype(self):
        return self.createFunctionPrototype(
                            'CopyAllFromBuffer',
                            params = {'*src' : 'void'})
                            
    def createCopyAllFromFunction(self):
        self.cFile.appendComment("Copy across *all* data from a buffer")
        self.cFile.appendComment("Data will be copied even if it is invalid (selection bit is cleared)")
        self.cFile.appendLine(self.copyAllFromPrototype())
        self.cFile.openBrace()
        self.cFile.appendLine("memcpy(&(log->data),src,sizeof({struct});".format(struct=dataStruct(self.prefix)))
        self.cFile.closeBrace()
        self.cFile.appendLine()

class LogVariable:

    #prefix = name of the 'device'
    #name = name of this variable
    #format = primitive datatype
    #comment = comment string
    def __init__(self, prefix, name, format, comment=None, units='dimensionless', scaler=1.0):
        self.prefix = prefix
        self.name = name
        self.format = self.parseFormat(format)
        self.comment = "//!< " + str(comment) if comment else ""
        self.units = units
        self.scaler = scaler
        
    def parseFormat(self, format):
        format = format.replace("unsigned","uint")
        format = format.replace("signed","int")
        if not format.endswith("_t"):
            format = format + "_t"
            
        return format
        
    #datatype definition string (with comment appended)
    def dataString(self):
        return "{datatype} {name}; {comment}".format(
                datatype = self.format,
                name = self.name,
                comment = self.comment)
                
    #bitfield definition string (with comment appended)
    def bitfieldString(self):
        return "unsigned {name} : 1; {comment}".format(
                name = self.name,
                comment = self.comment)
                
    #wrap a given function name
    def getFunctionName(self, fnName):
        return "{prefix}Log_{fn}{name}".format(prefix=self.prefix.capitalize(),name=self.name.capitalize(), fn=fnName.capitalize())
        
    #get a prototype for a function of a given name
    def getFunctionPrototype(self, fname, inline=False):
        s = 'inline ' if inline else ''
        s += 'void '
        s += self.getFunctionName(fname)
        s += '('
        s += topLevelStruct(self.prefix)
        s += ' *log, '
        s += self.format
        s += ' ' + self.name.lower() + ')'
        
        return s
        
    #return an enum line
    def getEnum(self):
        return "LOG_{pref}_{name}".format(pref=self.prefix.upper(),name=self.name.upper())
        
    #assume there is always a pointer to *log
    
    #check if a bit is set
    def checkBit(self):
        return 'if ({bit})'.format(bit=self.getBit())

    #check if a bit is set (in an external bitfield)
    def checkExternalBit(self, field):
        return 'if ({field}->{name})'.format(field=field,name=self.name)
        
    #check if a bit is not set
    def checkNotBit(self):
        return 'if ({bit} == 0)'.format(bit=self.getBit())
        
    #return access to the selection bit
    def getBit(self):
        return 'log->selection.{name}'.format(name=self.name)
    
    #code prototype to set the selection bit
    def setBit(self):
        return '{bit} = 1; //Set the {name} bit'.format(bit=self.getBit(), name=self.name)
        
    #code prototype to clear the selection bit
    def clearBit(self):
        return '{bit} = 0; //Clear the {name} bit'.format(bit=self.getBit(), name=self.name)
        
    def getSize(self):
        return 'sizeof(log->data.{name})'.format(name=self.name)
        
    def getPtr(self):
        return '&(log->data.{name})'.format(name=self.name)
        
    #add the variable to the struct
    def addVariable(self):
        return "log->data.{name} = {name}; //Add the '{name}' variable".format(name=self.name)
